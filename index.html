<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>나의 여행 아카이브 - 완벽한 실제 지구본</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 25%, #334155 50%, #1e293b 75%, #0f172a 100%);
            overflow: hidden;
            height: 100vh;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .spinner {
            border: 4px solid rgba(59, 130, 246, 0.3);
            border-radius: 50%;
            border-top: 4px solid #3b82f6;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .ui-panel {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            padding: 20px;
            z-index: 50;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .header {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }
        
        .header h1 {
            color: #1e293b;
            font-size: 26px;
            font-weight: 800;
            margin: 0;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .stats {
            top: 20px;
            right: 20px;
            min-width: 240px;
        }
        
        .stats h3 {
            color: #1e293b;
            margin-bottom: 16px;
            font-size: 18px;
            font-weight: 700;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            margin: 10px 0;
            font-size: 14px;
            font-weight: 500;
            color: #374151;
        }
        
        .color-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .controls {
            bottom: 20px;
            right: 20px;
        }
        
        .control-btn {
            background: linear-gradient(135deg, #3b82f6, #6366f1);
            color: white;
            border: none;
            padding: 12px 18px;
            border-radius: 10px;
            margin: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .control-btn:hover {
            background: linear-gradient(135deg, #2563eb, #5b21b6);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }
        
        .control-btn:active {
            transform: translateY(0px);
        }
        
        .country-info {
            bottom: 20px;
            left: 20px;
            min-width: 320px;
            max-height: 420px;
            overflow-y: auto;
            display: none;
        }
        
        .country-info h3 {
            color: #1e293b;
            margin-bottom: 16px;
            font-size: 20px;
            font-weight: 700;
            border-bottom: 3px solid #3b82f6;
            padding-bottom: 8px;
        }
        
        .trip-item {
            background: linear-gradient(135deg, #f8fafc, #e2e8f0);
            padding: 16px;
            margin: 10px 0;
            border-radius: 12px;
            border-left: 5px solid #3b82f6;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }
        
        .trip-item:hover {
            transform: translateX(4px);
        }
        
        .trip-location {
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 6px;
            font-size: 16px;
        }
        
        .trip-date {
            color: #64748b;
            font-size: 14px;
            font-weight: 500;
        }
        
        .close-btn {
            position: absolute;
            top: 12px;
            right: 18px;
            background: none;
            border: none;
            font-size: 24px;
            color: #64748b;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        
        .close-btn:hover {
            color: #ef4444;
        }
        
        .usage-guide {
            top: 110px;
            left: 20px;
            max-width: 300px;
            font-size: 13px;
        }
        
        .loading-status {
            color: #60a5fa;
            font-size: 16px;
            margin-top: 12px;
            font-weight: 500;
        }
        
        /* 스크롤바 스타일 */
        .country-info::-webkit-scrollbar {
            width: 6px;
        }
        
        .country-info::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        
        .country-info::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        
        .country-info::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">
            <div class="spinner"></div>
            <p style="font-size: 20px; font-weight: 600; margin-bottom: 8px;">실제 지구본을 생성하는 중...</p>
            <div class="loading-status" id="loadingStatus">초기화 중...</div>
        </div>
        
        <div class="ui-panel header">
            <h1>🌍 나의 여행 아카이브</h1>
        </div>
        
        <div class="ui-panel stats">
            <h3>📊 여행 통계</h3>
            <div class="stat-item">
                <div class="color-dot" style="background: #10b981;"></div>
                <span>1회 방문: 3개국</span>
            </div>
            <div class="stat-item">
                <div class="color-dot" style="background: #f59e0b;"></div>
                <span>2회 방문: 1개국</span>
            </div>
            <div class="stat-item">
                <div class="color-dot" style="background: #3b82f6;"></div>
                <span>3회 방문: 1개국</span>
            </div>
            <div class="stat-item">
                <div class="color-dot" style="background: #ef4444;"></div>
                <span>4회+ 방문: 1개국</span>
            </div>
        </div>
        
        <div class="ui-panel controls">
            <div style="margin-bottom: 12px; font-weight: 700; color: #1e293b; font-size: 16px;">🎮 지구본 조작</div>
            <button class="control-btn" onclick="resetView()">🏠 홈으로</button>
            <button class="control-btn" onclick="toggleAnimation()" id="animationBtn">⏸️ 정지</button>
            <button class="control-btn" onclick="toggleCountries()" id="countryBtn">🗺️ 경계선</button>
        </div>
        
        <div class="ui-panel country-info" id="countryInfo">
            <button class="close-btn" onclick="closeCountryInfo()">×</button>
            <h3 id="countryName">국가 정보</h3>
            <div id="tripsList"></div>
        </div>
        
        <div class="ui-panel usage-guide">
            <div style="color: #1e293b; font-weight: 700; margin-bottom: 8px;">💡 사용법</div>
            <div style="color: #475569; line-height: 1.5;">
                • <strong>마우스 드래그</strong>로 지구본 회전<br>
                • <strong>휠</strong>로 확대/축소<br>
                • <strong>빨간 마커 클릭</strong>으로 여행기록 보기<br>
                • <strong>🗺️ 버튼</strong>으로 나라 경계선 토글<br>
                • <strong>마커가 지구본과 함께 회전!</strong>
            </div>
        </div>
    </div>

    <script>
        console.log('🌍 완벽한 실제 지구본 스크립트 시작');
        
        // 전역 변수
        let scene, camera, renderer, globeGroup;
        let globe, countryLines;
        let markers = [];
        let isAnimating = true;
        let showCountries = true;
        
        // 여행 데이터
        const travelData = {
            '한국': {
                coords: [37.5665, 126.9780],
                visits: 0,
                trips: [
                    { location: '서울', dates: '상시 거주' },
                    { location: '부산', dates: '2024.08.11 - 08.12' },
                    { location: '제주도', dates: '2024.05.15 - 05.17' }
                ]
            },
            '일본': {
                coords: [36.2048, 138.2529],
                visits: 4,
                trips: [
                    { location: '도쿄', dates: '2023.04.11 - 04.15' },
                    { location: '오사카', dates: '2023.07.11 - 07.13' },
                    { location: '교토', dates: '2024.03.20 - 03.25' },
                    { location: '홋카이도', dates: '2024.12.01 - 12.05' }
                ]
            },
            '미국': {
                coords: [39.8283, -98.5795],
                visits: 2,
                trips: [
                    { location: '뉴욕', dates: '2023.09.15 - 09.22' },
                    { location: '로스앤젤레스', dates: '2024.06.10 - 06.17' }
                ]
            },
            '프랑스': {
                coords: [46.6034, 2.2137],
                visits: 3,
                trips: [
                    { location: '파리', dates: '2023.05.20 - 05.27' },
                    { location: '니스', dates: '2024.08.15 - 08.20' },
                    { location: '리옹', dates: '2024.11.10 - 11.15' }
                ]
            },
            '태국': {
                coords: [15.8700, 100.9925],
                visits: 1,
                trips: [{ location: '방콕', dates: '2024.02.28 - 03.07' }]
            },
            '영국': {
                coords: [55.3781, -3.4360],
                visits: 1,
                trips: [{ location: '런던', dates: '2024.09.05 - 09.12' }]
            },
            '이탈리아': {
                coords: [41.8719, 12.5674],
                visits: 1,
                trips: [{ location: '로마', dates: '2024.10.20 - 10.27' }]
            }
        };

        // 방문 횟수별 색상
        const visitColors = {
            0: 0xff6b6b, // 한국 (출발점)
            1: 0x10b981, // 1회 - 초록색
            2: 0xf59e0b, // 2회 - 노란색
            3: 0x3b82f6, // 3회 - 파란색
            4: 0xef4444  // 4회+ - 빨간색
        };

        // 나라 경계선 데이터
        const countryBoundaries = {
            '한국': [
                [126.117397, 37.470782], [126.482201, 37.664519], [127.327194, 37.840827],
                [127.963028, 37.706539], [128.659363, 37.238823], [128.989594, 36.628434],
                [129.584045, 35.983674], [129.216415, 35.272748], [128.054077, 34.898942],
                [126.485291, 33.948959], [125.887375, 34.478312], [125.354004, 35.139951],
                [125.827789, 35.685289], [126.117397, 37.470782]
            ],
            '일본': [
                [142.12, 45.52], [145.82, 44.12], [145.04, 42.98], [140.98, 41.25],
                [139.82, 38.95], [140.87, 37.37], [140.25, 36.05], [138.98, 34.67],
                [136.98, 33.15], [134.63, 34.15], [132.98, 33.88], [131.33, 33.08],
                [129.81, 32.79], [129.22, 31.89], [130.84, 31.51], [131.33, 30.98],
                [130.84, 30.13], [129.81, 32.79], [130.84, 33.39], [131.89, 34.02],
                [133.33, 34.67], [135.18, 35.15], [136.23, 35.65], [138.73, 36.29],
                [139.82, 37.82], [140.98, 39.25], [141.35, 41.37], [142.12, 45.52]
            ],
            '미국': [
                [-158.12, 21.54], [-155.98, 19.85], [-154.82, 18.89], [-178.35, 51.87],
                [-168.95, 65.67], [-124.73, 48.38], [-124.21, 46.19], [-122.34, 47.05],
                [-117.03, 49.00], [-95.15, 49.38], [-95.15, 28.93], [-94.04, 29.34],
                [-88.01, 30.36], [-84.32, 30.09], [-81.17, 31.34], [-80.84, 32.03],
                [-75.41, 35.75], [-71.02, 41.49], [-69.93, 44.05], [-67.79, 47.07],
                [-67.79, 45.70], [-83.23, 46.11], [-95.15, 49.38]
            ]
        };
        
        // 로딩 상태 업데이트
        function updateLoadingStatus(message) {
            document.getElementById('loadingStatus').textContent = message;
            console.log('📝', message);
        }

        // 좌표 변환 함수
        function latLngToVector3(lat, lng, radius = 1) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lng + 180) * (Math.PI / 180);
            
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));
            
            return new THREE.Vector3(x, y, z);
        }

        // 실제 지구 텍스처 생성 (고품질)
        function createUltraRealisticEarthTexture() {
            updateLoadingStatus('고품질 지구 텍스처 생성 중...');
            
            const canvas = document.createElement('canvas');
            canvas.width = 4096; // 더 높은 해상도
            canvas.height = 2048;
            const ctx = canvas.getContext('2d');
            
            // 바다 배경 (더 현실적인 그라디언트)
            const oceanGradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.height
            );
            oceanGradient.addColorStop(0, '#1e40af');   // 깊은 바다
            oceanGradient.addColorStop(0.3, '#2563eb'); // 중간 바다
            oceanGradient.addColorStop(0.6, '#3b82f6'); // 얕은 바다
            oceanGradient.addColorStop(0.8, '#60a5fa'); // 해안 바다
            oceanGradient.addColorStop(1, '#1e40af');   // 가장자리
            
            ctx.fillStyle = oceanGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 대륙들 (더 정확한 위치와 모양)
            const continents = [
                // 아시아 (한국, 일본, 중국 포함)
                { x: 2400, y: 400, w: 1200, h: 600, color: '#22c55e', name: '아시아' },
                // 유럽
                { x: 1800, y: 300, w: 600, h: 400, color: '#16a34a', name: '유럽' },
                // 아프리카  
                { x: 1900, y: 700, w: 400, h: 800, color: '#eab308', name: '아프리카' },
                // 북미
                { x: 400, y: 200, w: 800, h: 600, color: '#15803d', name: '북미' },
                // 남미
                { x: 800, y: 800, w: 300, h: 700, color: '#166534', name: '남미' },
                // 호주
                { x: 2800, y: 1200, w: 400, h: 200, color: '#ca8a04', name: '호주' },
                // 남극
                { x: 0, y: 1700, w: canvas.width, h: 348, color: '#f8fafc', name: '남극' }
            ];
            
            continents.forEach(continent => {
                // 더 자연스러운 대륙 모양
                ctx.fillStyle = continent.color;
                
                // 복잡한 해안선 만들기
                ctx.beginPath();
                const points = 50; // 더 많은 점으로 부드러운 곡선
                
                for (let i = 0; i <= points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    const radiusX = continent.w / 2;
                    const radiusY = continent.h / 2;
                    const centerX = continent.x + radiusX;
                    const centerY = continent.y + radiusY;
                    
                    // 더 복잡한 불규칙성
                    const noise1 = Math.sin(angle * 5) * 0.1;
                    const noise2 = Math.sin(angle * 13) * 0.05;
                    const noise3 = Math.sin(angle * 23) * 0.02;
                    const irregularity = 0.7 + noise1 + noise2 + noise3;
                    
                    const x = centerX + Math.cos(angle) * radiusX * irregularity;
                    const y = centerY + Math.sin(angle) * radiusY * irregularity;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.closePath();
                ctx.fill();
                
                // 해안선 효과 (더 진한 테두리)
                ctx.strokeStyle = '#0f766e';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // 내부 그림자 효과
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.stroke();
                ctx.shadowColor = 'transparent';
            });
            
            // 한국과 일본 정확한 위치에 상세 표시
            ctx.fillStyle = '#dc2626';
            
            // 한국 (한반도 모양 근사)
            ctx.beginPath();
            ctx.ellipse(2640, 550, 12, 20, Math.PI * 0.15, 0, Math.PI * 2);
            ctx.fill();
            
            // 제주도
            ctx.beginPath();
            ctx.ellipse(2635, 580, 3, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 일본 (일본 열도 모양 근사)
            ctx.beginPath();
            ctx.ellipse(2720, 540, 8, 35, Math.PI * 0.1, 0, Math.PI * 2);
            ctx.fill();
            
            // 홋카이도
            ctx.beginPath();
            ctx.ellipse(2730, 500, 8, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 중국 표시 (더 정확한 모양)
            ctx.fillStyle = '#f97316';
            ctx.beginPath();
            ctx.ellipse(2500, 600, 80, 60, Math.PI * 0.1, 0, Math.PI * 2);
            ctx.fill();
            
            // 미국 표시 (더 정확한 모양)
            ctx.fillStyle = '#2563eb';
            ctx.beginPath();
            ctx.ellipse(700, 450, 120, 70, Math.PI * 0.05, 0, Math.PI * 2);
            ctx.fill();
            
            // 경위도선 (더 세밀하게)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 1;
            
            // 경도선 (세로선) - 15도 간격
            for (let i = 0; i <= 24; i++) {
                const x = (canvas.width / 24) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // 위도선 (가로선) - 15도 간격
            for (let i = 0; i <= 12; i++) {
                const y = (canvas.height / 12) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // 주요 위도선 강조
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 2;
            
            // 적도
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
            
            // 북회귀선
            ctx.beginPath();
            ctx.moveTo(0, canvas.height * 0.35);
            ctx.lineTo(canvas.width, canvas.height * 0.35);
            ctx.stroke();
            
            // 남회귀선
            ctx.beginPath();
            ctx.moveTo(0, canvas.height * 0.65);
            ctx.lineTo(canvas.width, canvas.height * 0.65);
            ctx.stroke();
            
            updateLoadingStatus('고품질 지구 텍스처 생성 완료');
            return new THREE.CanvasTexture(canvas);
        }

        // 나라 경계선 생성
        function createCountryBoundaries() {
            updateLoadingStatus('국가 경계선 생성 중...');
            
            const countryGroup = new THREE.Group();
            
            Object.entries(countryBoundaries).forEach(([country, coordinates]) => {
                const points = coordinates.map(([lng, lat]) => {
                    return latLngToVector3(lat, lng, 1.002); // 지구본보다 약간 위에
                });
                
                // 닫힌 경계선을 위해 첫 번째 점을 마지막에 추가
                points.push(points[0]);
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.9,
                    linewidth: 3
                });
                
                const line = new THREE.Line(geometry, material);
                line.userData = { country };
                countryGroup.add(line);
            });
            
            updateLoadingStatus('국가 경계선 생성 완료');
            return countryGroup;
        }

        // 지구본 생성
        function createGlobe() {
            updateLoadingStatus('3D 지구본 메시 생성 중...');
            
            const geometry = new THREE.SphereGeometry(1, 128, 128); // 더 높은 해상도
            const earthTexture = createUltraRealisticEarthTexture();
            
            const material = new THREE.MeshPhongMaterial({
                map: earthTexture,
                shininess: 30,
                transparent: false,
                bumpScale: 0.02
            });
            
            const globe = new THREE.Mesh(geometry, material);
            globe.castShadow = true;
            globe.receiveShadow = true;
            
            updateLoadingStatus('3D 지구본 생성 완료');
            return globe;
        }

        // 마커 생성 (지구본의 자식으로)
        function createMarkers() {
            updateLoadingStatus('3D 여행 마커 생성 중...');
            
            const markerGroup = new THREE.Group();
            markers = []; // 배열 초기화
            
            Object.entries(travelData).forEach(([country, data]) => {
                const position = latLngToVector3(data.coords[0], data.coords[1], 1.08);
                
                // 마커 생성 (더 높은 품질)
                const geometry = new THREE.SphereGeometry(0.025, 16, 16);
                const color = visitColors[Math.min(data.visits, 4)];
                
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.6,
                    transparent: true,
                    opacity: 0.95,
                    shininess: 100
                });
                
                const marker = new THREE.Mesh(geometry, material);
                marker.position.copy(position);
                marker.userData = { country, data };
                marker.castShadow = true;
                
                // 방문 횟수에 따른 크기 조정
                const scale = data.visits === 0 ? 3.5 : 2.5 + (data.visits * 0.5);
                marker.scale.setScalar(scale);
                
                markerGroup.add(marker);
                markers.push(marker);
                
                // 마커 주변 링 생성
                const ringGeometry = new THREE.RingGeometry(0.04, 0.05, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(position);
                ring.lookAt(new THREE.Vector3(0, 0, 0));
                markerGroup.add(ring);
                
                // 국가 라벨 생성 (마커 그룹에 추가)
                const label = createLabel(country, position, color);
                markerGroup.add(label);
            });
            
            updateLoadingStatus('3D 여행 마커 생성 완료');
            return markerGroup;
        }

        // 라벨 생성
        function createLabel(countryName, position, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 160;
            canvas.height = 40;
            const ctx = canvas.getContext('2d');
            
            // 배경 (더 세련된 디자인)
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.9)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.7)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 테두리 (글로우 효과)
            const colorHex = `#${color.toString(16).padStart(6, '0')}`;
            ctx.strokeStyle = colorHex;
            ctx.lineWidth = 3;
            ctx.shadowColor = colorHex;
            ctx.shadowBlur = 8;
            ctx.strokeRect(2, 2, canvas.width-4, canvas.height-4);
            ctx.shadowBlur = 0;
            
            // 텍스트
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            ctx.shadowBlur = 4;
            ctx.fillText(countryName, canvas.width / 2, canvas.height / 2);
            ctx.shadowBlur = 0;
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                alphaTest: 0.1
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.3, 0.075, 1);
            
            const labelPosition = position.clone().multiplyScalar(1.18);
            sprite.position.copy(labelPosition);
            
            return sprite;
        }

        // 마우스 이벤트 처리
        function setupMouseEvents() {
            updateLoadingStatus('인터랙션 시스템 설정 중...');
            
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };
                
                // globeGroup 전체를 회전 (지구본, 마커, 라벨 모두 함께)
                globeGroup.rotation.x += deltaMove.y * 0.008;
                globeGroup.rotation.y += deltaMove.x * 0.008;
                
                // 회전 범위 제한 (너무 뒤집어지지 않게)
                globeGroup.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, globeGroup.rotation.x));
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('click', (e) => {
                if (isDragging) return;
                
                const rect = renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                // 마커들과의 교차점 검사
                const intersects = raycaster.intersectObjects(markers);
                
                if (intersects.length > 0) {
                    const marker = intersects[0].object;
                    showCountryInfo(marker.userData.country, marker.userData.data);
                } else {
                    closeCountryInfo();
                }
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.002;
                camera.position.z = Math.max(2.5, Math.min(10, camera.position.z));
            });
            
            updateLoadingStatus('인터랙션 시스템 설정 완료');
        }

        // 국가 정보 표시
        function showCountryInfo(country, data) {
            const countryInfo = document.getElementById('countryInfo');
            const countryName = document.getElementById('countryName');
            const tripsList = document.getElementById('tripsList');
            
            countryName.textContent = `🌍 ${country} (${data.visits === 0 ? '출발점' : data.visits + '회 방문'})`;
            
            tripsList.innerHTML = '';
            data.trips.forEach((trip, index) => {
                const tripDiv = document.createElement('div');
                tripDiv.className = 'trip-item';
                tripDiv.style.animationDelay = `${index * 0.1}s`;
                tripDiv.innerHTML = `
                    <div class="trip-location">📍 ${trip.location}</div>
                    <div class="trip-date">📅 ${trip.dates}</div>
                `;
                tripsList.appendChild(tripDiv);
            });
            
            countryInfo.style.display = 'block';
            countryInfo.style.animation = 'slideInLeft 0.3s ease-out';
        }

        // 국가 정보 닫기
        function closeCountryInfo() {
            const countryInfo = document.getElementById('countryInfo');
            countryInfo.style.animation = 'slideOutLeft 0.3s ease-in';
            setTimeout(() => {
                countryInfo.style.display = 'none';
            }, 300);
        }

        // 별 배경 생성
        function createStarField() {
            updateLoadingStatus('우주 배경 생성 중...');
            
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.7,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: false
            });
            
            const starVertices = [];
            const starColors = [];
            
            for (let i = 0; i < 3000; i++) {
                // 별의 위치 (구 형태로 배치)
                const radius = 50 + Math.random() * 50;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                starVertices.push(x, y, z);
                
                // 별의 색상 (약간의 변화)
                const brightness = 0.5 + Math.random() * 0.5;
                starColors.push(brightness, brightness, brightness);
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            return stars;
        }

        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            if (isAnimating && globeGroup) {
                // 전체 그룹을 회전 (마커들도 함께)
                globeGroup.rotation.y += 0.002;
                
                // 마커 펄스 효과
                markers.forEach((marker, index) => {
                    const time = Date.now() * 0.001 + index * 0.3;
                    const pulseFactor = 1 + Math.sin(time * 4) * 0.15;
                    const baseScale = marker.userData.data.visits === 0 ? 3.5 : 2.5 + (marker.userData.data.visits * 0.5);
                    marker.scale.setScalar(baseScale * pulseFactor);
                });
            }
            
            renderer.render(scene, camera);
        }

        // 컨트롤 함수들
        function resetView() {
            if (camera && globeGroup) {
                // 부드러운 애니메이션으로 원래 위치로
                const targetPosition = { x: 0, y: 0, z: 4 };
                const targetRotation = { x: 0, y: 0, z: 0 };
                
                // 간단한 애니메이션
                const duration = 1000; // 1초
                const startTime = Date.now();
                const startCameraZ = camera.position.z;
                const startRotationX = globeGroup.rotation.x;
                const startRotationY = globeGroup.rotation.y;
                
                function animateReset() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easeProgress = 1 - Math.pow(1 - progress, 3); // easeOut
                    
                    camera.position.z = startCameraZ + (targetPosition.z - startCameraZ) * easeProgress;
                    globeGroup.rotation.x = startRotationX + (targetRotation.x - startRotationX) * easeProgress;
                    globeGroup.rotation.y = startRotationY + (targetRotation.y - startRotationY) * easeProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateReset);
                    }
                }
                
                animateReset();
            }
        }

        function toggleAnimation() {
            isAnimating = !isAnimating;
            const btn = document.getElementById('animationBtn');
            btn.textContent = isAnimating ? '⏸️ 정지' : '▶️ 회전';
            btn.style.background = isAnimating ? 
                'linear-gradient(135deg, #ef4444, #dc2626)' : 
                'linear-gradient(135deg, #22c55e, #16a34a)';
        }
        
        function toggleCountries() {
            if (countryLines) {
                countryLines.visible = !countryLines.visible;
                showCountries = countryLines.visible;
                const btn = document.getElementById('countryBtn');
                btn.textContent = showCountries ? '🗺️ 경계선' : '🌍 지구본';
                btn.style.background = showCountries ? 
                    'linear-gradient(135deg, #8b5cf6, #7c3aed)' : 
                    'linear-gradient(135deg, #06b6d4, #0891b2)';
            }
        }

        // 초기화
        function init() {
            updateLoadingStatus('Three.js 엔진 초기화 중...');
            
            try {
                // Scene 생성
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000008); // 더 어두운 우주 배경

                // Camera 생성
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 4);

                // Renderer 생성 (고품질 설정)
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: false,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.2;
                
                document.getElementById('container').appendChild(renderer.domElement);

                updateLoadingStatus('고급 조명 시스템 설정 중...');
                
                // 조명 설정 (더 현실적으로)
                const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
                scene.add(ambientLight);

                // 태양광 (주 조명)
                const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
                sunLight.position.set(8, 5, 8);
                sunLight.castShadow = true;
                sunLight.shadow.mapSize.width = 2048;
                sunLight.shadow.mapSize.height = 2048;
                sunLight.shadow.camera.near = 0.5;
                sunLight.shadow.camera.far = 500;
                scene.add(sunLight);

                // 반사광 (지구 반대편)
                const moonLight = new THREE.DirectionalLight(0x6366f1, 0.4);
                moonLight.position.set(-8, -3, -8);
                scene.add(moonLight);

                // 포인트 라이트 (대기권 효과)
                const atmosphereLight = new THREE.PointLight(0x60a5fa, 0.6, 20);
                atmosphereLight.position.set(0, 0, 3);
                scene.add(atmosphereLight);

                updateLoadingStatus('지구본 시스템 구축 중...');

                // 글로브 그룹 생성 (모든 것을 담을 컨테이너)
                globeGroup = new THREE.Group();
                scene.add(globeGroup);
                
                // 지구본 생성 및 추가
                globe = createGlobe();
                globeGroup.add(globe);
                
                // 국가 경계선 생성 및 추가
                countryLines = createCountryBoundaries();
                globeGroup.add(countryLines);
                
                // 마커 생성 및 추가
                const markerGroup = createMarkers();
                globeGroup.add(markerGroup);

                // 별 배경 추가
                const stars = createStarField();
                scene.add(stars);

                // 마우스 이벤트 설정
                setupMouseEvents();

                updateLoadingStatus('최종 설정 중...');
                
                // 애니메이션 시작
                animate();
                
                updateLoadingStatus('🎉 완벽한 실제 지구본 완성!');
                
                // 로딩 화면 서서히 사라지기
                setTimeout(() => {
                    const loading = document.getElementById('loading');
                    loading.style.transition = 'opacity 0.8s ease-out';
                    loading.style.opacity = '0';
                    setTimeout(() => {
                        loading.style.display = 'none';
                    }, 800);
                }, 1500);
                
            } catch (error) {
                console.error('❌ 초기화 오류:', error);
                document.getElementById('loadingStatus').innerHTML = `
                    <div style="color: #ef4444;">
                        <strong>오류 발생!</strong><br>
                        ${error.message}<br>
                        브라우저를 새로고침해주세요.
                    </div>
                `;
            }
        }

        // 창 크기 변경 처리
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // 애니메이션 효과 CSS 추가
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInLeft {
                from { transform: translateX(-100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutLeft {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(-100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // Three.js 로드 확인 후 초기화
        if (typeof THREE !== 'undefined') {
            console.log('🚀 Three.js 로드 완료, 완벽한 실제 지구본 초기화 시작');
            init();
        } else {
            console.error('❌ Three.js 로드 실패');
            document.getElementById('loadingStatus').innerHTML = `
                <div style="color: #ef4444;">
                    <strong>Three.js 로드 실패!</strong><br>
                    네트워크 연결을 확인하고 새로고침해주세요.
                </div>
            `;
        }

    </script>
</body>
</html>